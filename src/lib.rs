extern crate proc_macro;
mod utils;

use proc_macro::TokenStream;
use proc_macro2::Span;
use quote::{format_ident, quote};
use utils::from_str::generated_from_str_impl;

use std::iter::repeat;
use syn::{self, Ident};

use crate::utils::{
    cast_extraction::get_cast_types,
    try_into::{build_type_variants_map, generate_try_into_impls},
    CastTypeData,
};

#[doc = include_str!("doc.md")]
// Define the `TypeCast` custom derive macro
#[proc_macro_derive(TypeCast, attributes(cast))]
pub fn derive_macro(input: TokenStream) -> TokenStream {
    let ast: syn::DeriveInput = syn::parse(input).unwrap();
    let name = &ast.ident;

    // Declare mutable variables to store cast types, conversions, and other related information
    let data_type_names = repeat(name.clone());
    let complex_data_type_names = repeat(name.clone());
    let data_kind_name = format_ident!("{}Cast", name.clone());
    let data_kind_names = repeat(data_kind_name.clone());
    let complex_data_kind_names = repeat(data_kind_name.clone());

    let string_data_kind_names = name.clone();

    let cast_type_data = &mut CastTypeData::default();

    let errors = if let syn::Data::Enum(data_enum) = ast.data {
        // Call the `get_cast_types` function to extract the required information from the Enum
        // This should return an empty Vec if successful or return a Vec<TokenTree> of errors otherwise
        get_cast_types(data_enum, cast_type_data)
    } else {
        return syn::Error::new_spanned(&ast, "TypeCast can only be derived for enums")
            .to_compile_error()
            .into();
    };

    if !errors.is_empty() {
        return proc_macro2::TokenStream::from_iter(errors.into_iter()).into();
    }

    let type_variants_map = build_type_variants_map(&cast_type_data);

    let generated_try_into_impls = generate_try_into_impls(&type_variants_map, &data_kind_name);

    let CastTypeData {
        cast_types,
        complex_cast_types,
        complex_cast_types_group,
        conversion,
        complex_conversion,
        number_of_array_elements,
        variants,
        complex_variants,
        string_types,
        string_variants,
        ..
    } = &cast_type_data;
    let mut parser_types: Vec<Ident> = Vec::new();
    for (cast_type, conversion) in cast_types.iter().zip(conversion) {
        let cast_type = cast_type.to_string();
        let conversion = conversion.to_string();
        parser_types.push(Ident::new(
            &format!("{conversion}{cast_type}"),
            Span::call_site(),
        ))
    }
    let mut complex_parser_types: Vec<Ident> = Vec::new();
    for (cast_type, conversion) in complex_cast_types.iter().zip(complex_conversion) {
        let cast_type = cast_type.to_string();
        let conversion = conversion.to_string();
        complex_parser_types.push(Ident::new(
            &format!("{conversion}{cast_type}"),
            Span::call_site(),
        ))
    }

    let gen = quote! {

        // Derive common traits and define the enum with primitive, complex, and string type variants. The enum's name is generated by appending "Cast" to the name of the enum decorated with #[derive(TypeCast)]
        #[derive(Clone, Debug, Serialize, Deserialize)]
        pub enum #data_kind_name {
            #(#variants(#cast_types),)*
            #(#complex_variants(#complex_cast_types_group),)*
            #(#string_variants(#string_types),)*
        }

        // Implement the parse method for the enum decorated with #[derive(TypeCast)]
        impl #name  {
            pub fn parse(self, input: &[u8]) -> IResult<&[u8], #data_kind_name> {
                // Match the current variant of the enum decorated with #[derive(TypeCast)] and convert the input bytes accordingly
                match self {
                    #(
                        #data_type_names::#variants => {
                            let (tail, bytes) = nom::number::complete::#parser_types(input)?;

                        Ok((tail, #data_kind_names::#variants (

                            bytes
                        )))

                    },
                    )*
                    #(
                        #complex_data_type_names::#complex_variants => {
                            let (tail, elements_vec) = nom::multi::count(nom::number::complete::#complex_parser_types, #number_of_array_elements)(input)?;

                            let out: [#complex_cast_types; #number_of_array_elements] = elements_vec.try_into().map_err(|_| nom::Err::Failure(nom::error::Error::new(input, nom::error::ErrorKind::Fail)))?;

                            Ok((tail, #complex_data_kind_names::#complex_variants(out)))
                        },
                    )*
                    // Handle string types
                    #(
                        #string_data_kind_names::#string_variants => {


                        let (tail,bytes) = nom::bytes::complete::take_while1(|c:u8| c.is_ascii())(input)?;
                        let string_result = String::from_utf8(bytes.to_vec()).map_err(|_| nom::Err::Failure(nom::error::Error::new(input, nom::error::ErrorKind::Fail)))?;

                        Ok((tail,#data_kind_name::#string_variants(string_result)))
                    }
                    )*
                 }
            }
        }
    };

    let generated_from_str_impl = generated_from_str_impl(name, cast_type_data);

    let combined_gen = quote! {
        #gen
        #generated_try_into_impls
        #generated_from_str_impl
    };
    combined_gen.into()
}
